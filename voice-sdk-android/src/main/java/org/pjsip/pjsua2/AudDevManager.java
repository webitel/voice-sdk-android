/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.pjsip.pjsua2;

/**
 * Audio device manager.
 */
public class AudDevManager {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  protected AudDevManager(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  protected static long getCPtr(AudDevManager obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        throw new UnsupportedOperationException("C++ destructor does not have public access");
      }
      swigCPtr = 0;
    }
  }

  /**
   * Get currently active capture sound devices. If sound devices has not been<br>
   * created, it is possible that the function returns -1 as device IDs.<br>
   * <br>
   * @return Device ID of the capture device.
   */
  public int getCaptureDev() throws java.lang.Exception {
    return pjsua2JNI.AudDevManager_getCaptureDev(swigCPtr, this);
  }

  /**
   * Get the AudioMedia of the capture audio device.<br>
   * <br>
   * @return Audio media for the capture device.
   */
  public AudioMedia getCaptureDevMedia() throws java.lang.Exception {
    return new AudioMedia(pjsua2JNI.AudDevManager_getCaptureDevMedia(swigCPtr, this), false);
  }

  /**
   * Get currently active playback sound devices. If sound devices has not<br>
   * been created, it is possible that the function returns -1 as device IDs.<br>
   * <br>
   * @return Device ID of the playback device.
   */
  public int getPlaybackDev() throws java.lang.Exception {
    return pjsua2JNI.AudDevManager_getPlaybackDev(swigCPtr, this);
  }

  /**
   * Get the AudioMedia of the speaker/playback audio device.<br>
   * <br>
   * @return Audio media for the speaker/playback device.
   */
  public AudioMedia getPlaybackDevMedia() throws java.lang.Exception {
    return new AudioMedia(pjsua2JNI.AudDevManager_getPlaybackDevMedia(swigCPtr, this), false);
  }

  /**
   * Select or change capture sound device. Application may call this<br>
   * function at any time to replace current sound device. Calling this <br>
   * method will not change the state of the sound device (opened/closed).<br>
   * <br>
   * @param capture_dev       Device ID of the capture device.
   */
  public void setCaptureDev(int capture_dev) throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setCaptureDev(swigCPtr, this, capture_dev);
  }

  /**
   * Select or change playback sound device. Application may call this<br>
   * function at any time to replace current sound device. Calling this <br>
   * method will not change the state of the sound device (opened/closed).<br>
   * <br>
   * @param playback_dev      Device ID of the playback device.
   */
  public void setPlaybackDev(int playback_dev) throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setPlaybackDev(swigCPtr, this, playback_dev);
  }

  /**
   * Enum all audio devices installed in the system.<br>
   * <br>
   * @return The list of audio device info.
   */
  public AudioDevInfoVector2 enumDev2() throws java.lang.Exception {
    return new AudioDevInfoVector2(pjsua2JNI.AudDevManager_enumDev2(swigCPtr, this), true);
  }

  /**
   * Set pjsua to use null sound device. The null sound device only provides<br>
   * the timing needed by the conference bridge, and will not interract with<br>
   * any hardware.
   */
  public void setNullDev() throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setNullDev(swigCPtr, this);
  }

  /**
   * Disconnect the main conference bridge from any sound devices, and let<br>
   * application connect the bridge to it's own sound device/master port.<br>
   * <br>
   * @return The port interface of the conference bridge,<br>
   *                          so that application can connect this to it's<br>
   *                          own sound device or master port.
   */
  public SWIGTYPE_p_p_void setNoDev() {
    long cPtr = pjsua2JNI.AudDevManager_setNoDev(swigCPtr, this);
    return (cPtr == 0) ? null : new SWIGTYPE_p_p_void(cPtr, false);
  }

  /**
   * Set sound device mode.<br>
   * <br>
   * Note that this method will open the sound device, using current<br>
   * active IDs set via setCaptureDev() or setPlaybackDev(), if the flag<br>
   * PJSUA_SND_DEV_NO_IMMEDIATE_OPEN is not specified.<br>
   * <br>
   * @param mode              The sound device mode, as bitmask combination <br>
   *                          of #pjsua_snd_dev_mode
   */
  public void setSndDevMode(long mode) throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setSndDevMode(swigCPtr, this, mode);
  }

  /**
   * Change the echo cancellation settings.<br>
   * <br>
   * The behavior of this function depends on whether the sound device is<br>
   * currently active, and if it is, whether device or software AEC is<br>
   * being used.<br>
   * <br>
   * If the sound device is currently active, and if the device supports AEC,<br>
   * this function will forward the change request to the device and it will<br>
   * be up to the device on whether support the request. If software AEC is<br>
   * being used (the software EC will be used if the device does not support<br>
   * AEC), this function will change the software EC settings. In all cases,<br>
   * the setting will be saved for future opening of the sound device.<br>
   * <br>
   * If the sound device is not currently active, this will only change the<br>
   * default AEC settings and the setting will be applied next time the<br>
   * sound device is opened.<br>
   * <br>
   * @param tail_msec         The tail length, in miliseconds. Set to zero to<br>
   *                          disable AEC.<br>
   * @param options           Options to be passed to pjmedia_echo_create().<br>
   *                          Normally the value should be zero.
   */
  public void setEcOptions(long tail_msec, long options) throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setEcOptions(swigCPtr, this, tail_msec, options);
  }

  /**
   * Get current echo canceller tail length.<br>
   * <br>
   * @return The EC tail length in milliseconds,<br>
   *                          If AEC is disabled, the value will be zero.
   */
  public long getEcTail() throws java.lang.Exception {
    return pjsua2JNI.AudDevManager_getEcTail(swigCPtr, this);
  }

  /**
   * Check whether the sound device is currently active. The sound device<br>
   * may be inactive if the application has set the auto close feature to<br>
   * non-zero (the sndAutoCloseTime setting in MediaConfig), or<br>
   * if null sound device or no sound device has been configured via the<br>
   * setNoDev() function.
   */
  public boolean sndIsActive() {
    return pjsua2JNI.AudDevManager_sndIsActive(swigCPtr, this);
  }

  /**
   * Refresh the list of sound devices installed in the system. This method<br>
   * will only refresh the list of audio device so all active audio streams<br>
   * will be unaffected. After refreshing the device list, application MUST<br>
   * make sure to update all index references to audio devices before calling<br>
   * any method that accepts audio device index as its parameter.
   */
  public void refreshDevs() throws java.lang.Exception {
    pjsua2JNI.AudDevManager_refreshDevs(swigCPtr, this);
  }

  /**
   * Get the number of sound devices installed in the system.<br>
   * <br>
   * @return The number of sound devices installed in the<br>
   *                          system.
   */
  public long getDevCount() {
    return pjsua2JNI.AudDevManager_getDevCount(swigCPtr, this);
  }

  /**
   * Get device information.<br>
   * <br>
   * @param id                The audio device ID.<br>
   * <br>
   * @return The device information which will be filled in<br>
   *                          by this method once it returns successfully.
   */
  public AudioDevInfo getDevInfo(int id) throws java.lang.Exception {
    return new AudioDevInfo(pjsua2JNI.AudDevManager_getDevInfo(swigCPtr, this, id), true);
  }

  /**
   * Lookup device index based on the driver and device name.<br>
   * <br>
   * @param drv_name          The driver name.<br>
   * @param dev_name          The device name.<br>
   * <br>
   * @return The device ID. If the device is not found,<br>
   *                          Error will be thrown.
   */
  public int lookupDev(String drv_name, String dev_name) throws java.lang.Exception {
    return pjsua2JNI.AudDevManager_lookupDev(swigCPtr, this, drv_name, dev_name);
  }

  /**
   * Get string info for the specified capability.<br>
   * <br>
   * @param cap               The capability ID.<br>
   * <br>
   * @return Capability name.
   */
  public String capName(int cap) {
    return pjsua2JNI.AudDevManager_capName(swigCPtr, this, cap);
  }

  /**
   * This will configure audio format capability (other than PCM) to the<br>
   * sound device being used. If sound device is currently active, the method<br>
   * will forward the setting to the sound device instance to be applied<br>
   * immediately, if it supports it.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_AUD_DEV_CAP_EXT_FORMAT capability in AudioDevInfo.caps flags,<br>
   * otherwise Error will be thrown.<br>
   * <br>
   * Note that in case the setting is kept for future use, it will be applied<br>
   * to any devices, even when application has changed the sound device to be<br>
   * used.<br>
   * <br>
   * @param format            The audio format.<br>
   * @param keep              Specify whether the setting is to be kept for<br>
   *                          future use.
   */
  public void setExtFormat(MediaFormatAudio format, boolean keep) throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setExtFormat__SWIG_0(swigCPtr, this, MediaFormatAudio.getCPtr(format), format, keep);
  }

  /**
   * This will configure audio format capability (other than PCM) to the<br>
   * sound device being used. If sound device is currently active, the method<br>
   * will forward the setting to the sound device instance to be applied<br>
   * immediately, if it supports it.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_AUD_DEV_CAP_EXT_FORMAT capability in AudioDevInfo.caps flags,<br>
   * otherwise Error will be thrown.<br>
   * <br>
   * Note that in case the setting is kept for future use, it will be applied<br>
   * to any devices, even when application has changed the sound device to be<br>
   * used.<br>
   * <br>
   * @param format            The audio format.<br>
   * 
   */
  public void setExtFormat(MediaFormatAudio format) throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setExtFormat__SWIG_1(swigCPtr, this, MediaFormatAudio.getCPtr(format), format);
  }

  /**
   * Get the audio format capability (other than PCM) of the sound device<br>
   * being used. If sound device is currently active, the method will forward<br>
   * the request to the sound device. If sound device is currently inactive,<br>
   * and if application had previously set the setting and mark the setting<br>
   * as kept, then that setting will be returned. Otherwise, this method<br>
   * will raise error.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_AUD_DEV_CAP_EXT_FORMAT capability in AudioDevInfo.caps flags,<br>
   * otherwise Error will be thrown.<br>
   * <br>
   * @return The audio format.
   */
  public MediaFormatAudio getExtFormat() throws java.lang.Exception {
    return new MediaFormatAudio(pjsua2JNI.AudDevManager_getExtFormat(swigCPtr, this), true);
  }

  /**
   * This will configure audio input latency control or query capability to<br>
   * the sound device being used. If sound device is currently active,<br>
   * the method will forward the setting to the sound device instance to be<br>
   * applied immediately, if it supports it.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_AUD_DEV_CAP_INPUT_LATENCY capability in AudioDevInfo.caps flags,<br>
   * otherwise Error will be thrown.<br>
   * <br>
   * Note that in case the setting is kept for future use, it will be applied<br>
   * to any devices, even when application has changed the sound device to be<br>
   * used.<br>
   * <br>
   * @param latency_msec      The input latency.<br>
   * @param keep              Specify whether the setting is to be kept<br>
   *                          for future use.
   */
  public void setInputLatency(long latency_msec, boolean keep) throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setInputLatency__SWIG_0(swigCPtr, this, latency_msec, keep);
  }

  /**
   * This will configure audio input latency control or query capability to<br>
   * the sound device being used. If sound device is currently active,<br>
   * the method will forward the setting to the sound device instance to be<br>
   * applied immediately, if it supports it.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_AUD_DEV_CAP_INPUT_LATENCY capability in AudioDevInfo.caps flags,<br>
   * otherwise Error will be thrown.<br>
   * <br>
   * Note that in case the setting is kept for future use, it will be applied<br>
   * to any devices, even when application has changed the sound device to be<br>
   * used.<br>
   * <br>
   * @param latency_msec      The input latency.<br>
   * 
   */
  public void setInputLatency(long latency_msec) throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setInputLatency__SWIG_1(swigCPtr, this, latency_msec);
  }

  /**
   * Get the audio input latency control or query capability of the sound<br>
   * device being used. If sound device is currently active, the method will<br>
   * forward the request to the sound device. If sound device is currently<br>
   * inactive, and if application had previously set the setting and mark the<br>
   * setting as kept, then that setting will be returned. Otherwise, this<br>
   * method will raise error.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_AUD_DEV_CAP_INPUT_LATENCY capability in AudioDevInfo.caps flags,<br>
   * otherwise Error will be thrown.<br>
   * <br>
   * @return The audio input latency.
   */
  public long getInputLatency() throws java.lang.Exception {
    return pjsua2JNI.AudDevManager_getInputLatency(swigCPtr, this);
  }

  /**
   * This will configure audio output latency control or query capability to<br>
   * the sound device being used. If sound device is currently active,<br>
   * the method will forward the setting to the sound device instance to be<br>
   * applied immediately, if it supports it.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_AUD_DEV_CAP_OUTPUT_LATENCY capability in AudioDevInfo.caps flags,<br>
   * otherwise Error will be thrown.<br>
   * <br>
   * Note that in case the setting is kept for future use, it will be applied<br>
   * to any devices, even when application has changed the sound device to be<br>
   * used.<br>
   * <br>
   * @param latency_msec      The output latency.<br>
   * @param keep              Specify whether the setting is to be kept<br>
   *                          for future use.
   */
  public void setOutputLatency(long latency_msec, boolean keep) throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setOutputLatency__SWIG_0(swigCPtr, this, latency_msec, keep);
  }

  /**
   * This will configure audio output latency control or query capability to<br>
   * the sound device being used. If sound device is currently active,<br>
   * the method will forward the setting to the sound device instance to be<br>
   * applied immediately, if it supports it.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_AUD_DEV_CAP_OUTPUT_LATENCY capability in AudioDevInfo.caps flags,<br>
   * otherwise Error will be thrown.<br>
   * <br>
   * Note that in case the setting is kept for future use, it will be applied<br>
   * to any devices, even when application has changed the sound device to be<br>
   * used.<br>
   * <br>
   * @param latency_msec      The output latency.<br>
   * 
   */
  public void setOutputLatency(long latency_msec) throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setOutputLatency__SWIG_1(swigCPtr, this, latency_msec);
  }

  /**
   * Get the audio output latency control or query capability of the sound<br>
   * device being used. If sound device is currently active, the method will<br>
   * forward the request to the sound device. If sound device is currently<br>
   * inactive, and if application had previously set the setting and mark the<br>
   * setting as kept, then that setting will be returned. Otherwise, this<br>
   * method will raise error.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_AUD_DEV_CAP_OUTPUT_LATENCY capability in AudioDevInfo.caps flags,<br>
   * otherwise Error will be thrown.<br>
   * <br>
   * @return The audio output latency.
   */
  public long getOutputLatency() throws java.lang.Exception {
    return pjsua2JNI.AudDevManager_getOutputLatency(swigCPtr, this);
  }

  /**
   * This will configure audio input volume level capability to the<br>
   * sound device being used.<br>
   * If sound device is currently active, the method will forward the<br>
   * setting to the sound device instance to be applied immediately,<br>
   * if it supports it.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_AUD_DEV_CAP_INPUT_VOLUME_SETTING capability in AudioDevInfo.caps<br>
   * flags, otherwise Error will be thrown.<br>
   * <br>
   * Note that in case the setting is kept for future use, it will be applied<br>
   * to any devices, even when application has changed the sound device to be<br>
   * used.<br>
   * <br>
   * @param volume            The input volume level, in percent.<br>
   * @param keep              Specify whether the setting is to be kept for<br>
   *                          future use.
   */
  public void setInputVolume(long volume, boolean keep) throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setInputVolume__SWIG_0(swigCPtr, this, volume, keep);
  }

  /**
   * This will configure audio input volume level capability to the<br>
   * sound device being used.<br>
   * If sound device is currently active, the method will forward the<br>
   * setting to the sound device instance to be applied immediately,<br>
   * if it supports it.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_AUD_DEV_CAP_INPUT_VOLUME_SETTING capability in AudioDevInfo.caps<br>
   * flags, otherwise Error will be thrown.<br>
   * <br>
   * Note that in case the setting is kept for future use, it will be applied<br>
   * to any devices, even when application has changed the sound device to be<br>
   * used.<br>
   * <br>
   * @param volume            The input volume level, in percent.<br>
   * 
   */
  public void setInputVolume(long volume) throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setInputVolume__SWIG_1(swigCPtr, this, volume);
  }

  /**
   * Get the audio input volume level capability of the sound device being<br>
   * used. If sound device is currently active, the method will forward the<br>
   * request to the sound device. If sound device is currently inactive,<br>
   * and if application had previously set the setting and mark the setting<br>
   * as kept, then that setting will be returned. Otherwise, this method<br>
   * will raise error.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_AUD_DEV_CAP_INPUT_VOLUME_SETTING capability in AudioDevInfo.caps<br>
   * flags, otherwise Error will be thrown.     *<br>
   * <br>
   * @return The audio input volume level, in percent.
   */
  public long getInputVolume() throws java.lang.Exception {
    return pjsua2JNI.AudDevManager_getInputVolume(swigCPtr, this);
  }

  /**
   * This will configure audio output volume level capability to the sound<br>
   * device being used. If sound device is currently active, the method will<br>
   * forward the setting to the sound device instance to be applied<br>
   * immediately, if it supports it.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_AUD_DEV_CAP_OUTPUT_VOLUME_SETTING capability in AudioDevInfo.caps<br>
   * flags, otherwise Error will be thrown.<br>
   * <br>
   * Note that in case the setting is kept for future use, it will be applied<br>
   * to any devices, even when application has changed the sound device to be<br>
   * used.<br>
   * <br>
   * @param volume            The output volume level, in percent.<br>
   * @param keep              Specify whether the setting is to be kept<br>
   *                          for future use.
   */
  public void setOutputVolume(long volume, boolean keep) throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setOutputVolume__SWIG_0(swigCPtr, this, volume, keep);
  }

  /**
   * This will configure audio output volume level capability to the sound<br>
   * device being used. If sound device is currently active, the method will<br>
   * forward the setting to the sound device instance to be applied<br>
   * immediately, if it supports it.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_AUD_DEV_CAP_OUTPUT_VOLUME_SETTING capability in AudioDevInfo.caps<br>
   * flags, otherwise Error will be thrown.<br>
   * <br>
   * Note that in case the setting is kept for future use, it will be applied<br>
   * to any devices, even when application has changed the sound device to be<br>
   * used.<br>
   * <br>
   * @param volume            The output volume level, in percent.<br>
   * 
   */
  public void setOutputVolume(long volume) throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setOutputVolume__SWIG_1(swigCPtr, this, volume);
  }

  /**
   * Get the audio output volume level capability of the sound device being<br>
   * used. If sound device is currently active, the method will forward the<br>
   * request to the sound device. If sound device is currently inactive,<br>
   * and if application had previously set the setting and mark the setting<br>
   * as kept, then that setting will be returned. Otherwise, this method<br>
   * will raise error.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_AUD_DEV_CAP_OUTPUT_VOLUME_SETTING capability in AudioDevInfo.caps<br>
   * flags, otherwise Error will be thrown.<br>
   * <br>
   * @return The audio output volume level, in percent.
   */
  public long getOutputVolume() throws java.lang.Exception {
    return pjsua2JNI.AudDevManager_getOutputVolume(swigCPtr, this);
  }

  /**
   * Get the audio input signal level capability of the sound device being<br>
   * used. If sound device is currently active, the method will forward the<br>
   * request to the sound device. If sound device is currently inactive,<br>
   * and if application had previously set the setting and mark the setting<br>
   * as kept, then that setting will be returned. Otherwise, this method<br>
   * will raise error.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_AUD_DEV_CAP_INPUT_SIGNAL_METER capability in AudioDevInfo.caps<br>
   * flags, otherwise Error will be thrown.<br>
   * <br>
   * @return The audio input signal level, in percent.
   */
  public long getInputSignal() throws java.lang.Exception {
    return pjsua2JNI.AudDevManager_getInputSignal(swigCPtr, this);
  }

  /**
   * Get the audio output signal level capability of the sound device being<br>
   * used. If sound device is currently active, the method will forward the<br>
   * request to the sound device. If sound device is currently inactive,<br>
   * and if application had previously set the setting and mark the setting<br>
   * as kept, then that setting will be returned. Otherwise, this method<br>
   * will raise error.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_AUD_DEV_CAP_OUTPUT_SIGNAL_METER capability in AudioDevInfo.caps<br>
   * flags, otherwise Error will be thrown.<br>
   * <br>
   * @return The audio output signal level, in percent.
   */
  public long getOutputSignal() throws java.lang.Exception {
    return pjsua2JNI.AudDevManager_getOutputSignal(swigCPtr, this);
  }

  /**
   * This will configure audio input route capability to the sound device<br>
   * being used. If sound device is currently active, the method will<br>
   * forward the setting to the sound device instance to be applied<br>
   * immediately, if it supports it.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_AUD_DEV_CAP_INPUT_ROUTE capability in AudioDevInfo.caps<br>
   * flags, otherwise Error will be thrown.<br>
   * <br>
   * Note that in case the setting is kept for future use, it will be applied<br>
   * to any devices, even when application has changed the sound device to be<br>
   * used.<br>
   * <br>
   * @param route             The audio input route.<br>
   * @param keep              Specify whether the setting is to be kept<br>
   *                          for future use.
   */
  public void setInputRoute(int route, boolean keep) throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setInputRoute__SWIG_0(swigCPtr, this, route, keep);
  }

  /**
   * This will configure audio input route capability to the sound device<br>
   * being used. If sound device is currently active, the method will<br>
   * forward the setting to the sound device instance to be applied<br>
   * immediately, if it supports it.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_AUD_DEV_CAP_INPUT_ROUTE capability in AudioDevInfo.caps<br>
   * flags, otherwise Error will be thrown.<br>
   * <br>
   * Note that in case the setting is kept for future use, it will be applied<br>
   * to any devices, even when application has changed the sound device to be<br>
   * used.<br>
   * <br>
   * @param route             The audio input route.<br>
   * 
   */
  public void setInputRoute(int route) throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setInputRoute__SWIG_1(swigCPtr, this, route);
  }

  /**
   * Get the audio input route capability of the sound device being used.<br>
   * If sound device is currently active, the method will forward the<br>
   * request to the sound device. If sound device is currently inactive,<br>
   * and if application had previously set the setting and mark the setting<br>
   * as kept, then that setting will be returned. Otherwise, this method<br>
   * will raise error.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_AUD_DEV_CAP_INPUT_ROUTE capability in AudioDevInfo.caps<br>
   * flags, otherwise Error will be thrown.<br>
   * <br>
   * @return The audio input route.
   */
  public int getInputRoute() throws java.lang.Exception {
    return pjsua2JNI.AudDevManager_getInputRoute(swigCPtr, this);
  }

  /**
   * This will configure audio output route capability to the sound device<br>
   * being used. If sound device is currently active, the method will<br>
   * forward the setting to the sound device instance to be applied<br>
   * immediately, if it supports it.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_AUD_DEV_CAP_OUTPUT_ROUTE capability in AudioDevInfo.caps<br>
   * flags, otherwise Error will be thrown.<br>
   * <br>
   * Note that in case the setting is kept for future use, it will be applied<br>
   * to any devices, even when application has changed the sound device to be<br>
   * used.<br>
   * <br>
   * @param route             The audio output route.<br>
   * @param keep              Specify whether the setting is to be kept<br>
   *                          for future use.
   */
  public void setOutputRoute(int route, boolean keep) throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setOutputRoute__SWIG_0(swigCPtr, this, route, keep);
  }

  /**
   * This will configure audio output route capability to the sound device<br>
   * being used. If sound device is currently active, the method will<br>
   * forward the setting to the sound device instance to be applied<br>
   * immediately, if it supports it.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_AUD_DEV_CAP_OUTPUT_ROUTE capability in AudioDevInfo.caps<br>
   * flags, otherwise Error will be thrown.<br>
   * <br>
   * Note that in case the setting is kept for future use, it will be applied<br>
   * to any devices, even when application has changed the sound device to be<br>
   * used.<br>
   * <br>
   * @param route             The audio output route.<br>
   * 
   */
  public void setOutputRoute(int route) throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setOutputRoute__SWIG_1(swigCPtr, this, route);
  }

  /**
   * Get the audio output route capability of the sound device being used.<br>
   * If sound device is currently active, the method will forward the<br>
   * request to the sound device. If sound device is currently inactive,<br>
   * and if application had previously set the setting and mark the setting<br>
   * as kept, then that setting will be returned. Otherwise, this method<br>
   * will raise error.<br>
   * <br>
   * This method is only valid if the device has<br>
   * PJMEDIA_AUD_DEV_CAP_OUTPUT_ROUTE capability in AudioDevInfo.caps<br>
   * flags, otherwise Error will be thrown.<br>
   * <br>
   * @return The audio output route.
   */
  public int getOutputRoute() throws java.lang.Exception {
    return pjsua2JNI.AudDevManager_getOutputRoute(swigCPtr, this);
  }

  /**
   * This will configure audio voice activity detection capability to<br>
   * the sound device being used. If sound device is currently active,<br>
   * the method will forward the setting to the sound device instance<br>
   * to be applied immediately, if it supports it.<br>
   * <br>
   * This method is only valid if the device has PJMEDIA_AUD_DEV_CAP_VAD<br>
   * capability in AudioDevInfo.caps flags, otherwise Error will be thrown.<br>
   * <br>
   * Note that in case the setting is kept for future use, it will be applied<br>
   * to any devices, even when application has changed the sound device to be<br>
   * used.<br>
   * <br>
   * @param enable            Enable/disable voice activity detection<br>
   *                          feature. Set true to enable.<br>
   * @param keep              Specify whether the setting is to be kept for<br>
   *                          future use.
   */
  public void setVad(boolean enable, boolean keep) throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setVad__SWIG_0(swigCPtr, this, enable, keep);
  }

  /**
   * This will configure audio voice activity detection capability to<br>
   * the sound device being used. If sound device is currently active,<br>
   * the method will forward the setting to the sound device instance<br>
   * to be applied immediately, if it supports it.<br>
   * <br>
   * This method is only valid if the device has PJMEDIA_AUD_DEV_CAP_VAD<br>
   * capability in AudioDevInfo.caps flags, otherwise Error will be thrown.<br>
   * <br>
   * Note that in case the setting is kept for future use, it will be applied<br>
   * to any devices, even when application has changed the sound device to be<br>
   * used.<br>
   * <br>
   * @param enable            Enable/disable voice activity detection<br>
   *                          feature. Set true to enable.<br>
   * 
   */
  public void setVad(boolean enable) throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setVad__SWIG_1(swigCPtr, this, enable);
  }

  /**
   * Get the audio voice activity detection capability of the sound device<br>
   * being used. If sound device is currently active, the method will<br>
   * forward the request to the sound device. If sound device is currently<br>
   * inactive, and if application had previously set the setting and mark<br>
   * the setting as kept, then that setting will be returned. Otherwise,<br>
   * this method will raise error.<br>
   * <br>
   * This method is only valid if the device has PJMEDIA_AUD_DEV_CAP_VAD<br>
   * capability in AudioDevInfo.caps flags, otherwise Error will be thrown.<br>
   * <br>
   * @return The audio voice activity detection feature.
   */
  public boolean getVad() throws java.lang.Exception {
    return pjsua2JNI.AudDevManager_getVad(swigCPtr, this);
  }

  /**
   * This will configure audio comfort noise generation capability to<br>
   * the sound device being used. If sound device is currently active,<br>
   * the method will forward the setting to the sound device instance<br>
   * to be applied immediately, if it supports it.<br>
   * <br>
   * This method is only valid if the device has PJMEDIA_AUD_DEV_CAP_CNG<br>
   * capability in AudioDevInfo.caps flags, otherwise Error will be thrown.<br>
   * <br>
   * Note that in case the setting is kept for future use, it will be applied<br>
   * to any devices, even when application has changed the sound device to be<br>
   * used.<br>
   * <br>
   * @param enable            Enable/disable comfort noise generation<br>
   *                          feature. Set true to enable.<br>
   * @param keep              Specify whether the setting is to be kept for<br>
   *                          future use.
   */
  public void setCng(boolean enable, boolean keep) throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setCng__SWIG_0(swigCPtr, this, enable, keep);
  }

  /**
   * This will configure audio comfort noise generation capability to<br>
   * the sound device being used. If sound device is currently active,<br>
   * the method will forward the setting to the sound device instance<br>
   * to be applied immediately, if it supports it.<br>
   * <br>
   * This method is only valid if the device has PJMEDIA_AUD_DEV_CAP_CNG<br>
   * capability in AudioDevInfo.caps flags, otherwise Error will be thrown.<br>
   * <br>
   * Note that in case the setting is kept for future use, it will be applied<br>
   * to any devices, even when application has changed the sound device to be<br>
   * used.<br>
   * <br>
   * @param enable            Enable/disable comfort noise generation<br>
   *                          feature. Set true to enable.<br>
   * 
   */
  public void setCng(boolean enable) throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setCng__SWIG_1(swigCPtr, this, enable);
  }

  /**
   * Get the audio comfort noise generation capability of the sound device<br>
   * being used. If sound device is currently active, the method will<br>
   * forward the request to the sound device. If sound device is currently<br>
   * inactive, and if application had previously set the setting and mark<br>
   * the setting as kept, then that setting will be returned. Otherwise,<br>
   * this method will raise error.<br>
   * <br>
   * This method is only valid if the device has PJMEDIA_AUD_DEV_CAP_CNG<br>
   * capability in AudioDevInfo.caps flags, otherwise Error will be thrown.<br>
   * <br>
   * @return The audio comfort noise generation feature.
   */
  public boolean getCng() throws java.lang.Exception {
    return pjsua2JNI.AudDevManager_getCng(swigCPtr, this);
  }

  /**
   * This will configure audio packet loss concealment capability to<br>
   * the sound device being used. If sound device is currently active,<br>
   * the method will forward the setting to the sound device instance<br>
   * to be applied immediately, if it supports it.<br>
   * <br>
   * This method is only valid if the device has PJMEDIA_AUD_DEV_CAP_PLC<br>
   * capability in AudioDevInfo.caps flags, otherwise Error will be thrown.<br>
   * <br>
   * Note that in case the setting is kept for future use, it will be applied<br>
   * to any devices, even when application has changed the sound device to be<br>
   * used.<br>
   * <br>
   * @param enable            Enable/disable packet loss concealment<br>
   *                          feature. Set true to enable.<br>
   * @param keep              Specify whether the setting is to be kept for<br>
   *                          future use.
   */
  public void setPlc(boolean enable, boolean keep) throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setPlc__SWIG_0(swigCPtr, this, enable, keep);
  }

  /**
   * This will configure audio packet loss concealment capability to<br>
   * the sound device being used. If sound device is currently active,<br>
   * the method will forward the setting to the sound device instance<br>
   * to be applied immediately, if it supports it.<br>
   * <br>
   * This method is only valid if the device has PJMEDIA_AUD_DEV_CAP_PLC<br>
   * capability in AudioDevInfo.caps flags, otherwise Error will be thrown.<br>
   * <br>
   * Note that in case the setting is kept for future use, it will be applied<br>
   * to any devices, even when application has changed the sound device to be<br>
   * used.<br>
   * <br>
   * @param enable            Enable/disable packet loss concealment<br>
   *                          feature. Set true to enable.<br>
   * 
   */
  public void setPlc(boolean enable) throws java.lang.Exception {
    pjsua2JNI.AudDevManager_setPlc__SWIG_1(swigCPtr, this, enable);
  }

  /**
   * Get the audio packet loss concealment capability of the sound device<br>
   * being used. If sound device is currently active, the method will<br>
   * forward the request to the sound device. If sound device is currently<br>
   * inactive, and if application had previously set the setting and mark<br>
   * the setting as kept, then that setting will be returned. Otherwise,<br>
   * this method will raise error.<br>
   * <br>
   * This method is only valid if the device has PJMEDIA_AUD_DEV_CAP_PLC<br>
   * capability in AudioDevInfo.caps flags, otherwise Error will be thrown.<br>
   * <br>
   * @return The audio packet loss concealment feature.
   */
  public boolean getPlc() throws java.lang.Exception {
    return pjsua2JNI.AudDevManager_getPlc(swigCPtr, this);
  }

}
