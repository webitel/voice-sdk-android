/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.pjsip.pjsua2;

/**
 * Call.
 */
public class Call {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  protected Call(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  protected static long getCPtr(Call obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        pjsua2JNI.delete_Call(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  protected void swigDirectorDisconnect() {
    swigCMemOwn = false;
    delete();
  }

  public void swigReleaseOwnership() {
    swigCMemOwn = false;
    pjsua2JNI.Call_change_ownership(this, swigCPtr, false);
  }

  public void swigTakeOwnership() {
    swigCMemOwn = true;
    pjsua2JNI.Call_change_ownership(this, swigCPtr, true);
  }

  /**
   * Constructor.
   */
  public Call(Account acc, int call_id) {
    this(pjsua2JNI.new_Call__SWIG_0(Account.getCPtr(acc), acc, call_id), true);
    pjsua2JNI.Call_director_connect(this, swigCPtr, true, true);
  }

  /**
   * Constructor.
   */
  public Call(Account acc) {
    this(pjsua2JNI.new_Call__SWIG_1(Account.getCPtr(acc), acc), true);
    pjsua2JNI.Call_director_connect(this, swigCPtr, true, true);
  }

  /**
   * Obtain detail information about this call.<br>
   * <br>
   * @return Call info.
   */
  public CallInfo getInfo() throws java.lang.Exception {
    return new CallInfo(pjsua2JNI.Call_getInfo(swigCPtr, this), true);
  }

  /**
   * Check if this call has active INVITE session and the INVITE<br>
   * session has not been disconnected.<br>
   * <br>
   * @return True if call is active.
   */
  public boolean isActive() {
    return pjsua2JNI.Call_isActive(swigCPtr, this);
  }

  /**
   * Get PJSUA-LIB call ID or index associated with this call.<br>
   * <br>
   * @return Integer greater than or equal to zero.
   */
  public int getId() {
    return pjsua2JNI.Call_getId(swigCPtr, this);
  }

  /**
   * Get the Call class for the specified call Id.<br>
   * <br>
   * @param call_id       The call ID to lookup<br>
   * <br>
   * @return The Call instance or NULL if not found.
   */
  public static Call lookup(int call_id) {
    long cPtr = pjsua2JNI.Call_lookup(call_id);
    return (cPtr == 0) ? null : new Call(cPtr, false);
  }

  /**
   * Check if call has an active media session.<br>
   * <br>
   * @return True if yes.
   */
  public boolean hasMedia() {
    return pjsua2JNI.Call_hasMedia(swigCPtr, this);
  }

  /**
   * Warning: deprecated, use getAudioMedia() instead. This function is not<br>
   * safe in multithreaded environment.<br>
   * <br>
   * Get media for the specified media index.<br>
   * <br>
   * @param med_idx       Media index.<br>
   * <br>
   * @return The media or NULL if invalid or inactive.
   */
  public Media getMedia(long med_idx) {
    long cPtr = pjsua2JNI.Call_getMedia(swigCPtr, this, med_idx);
    return (cPtr == 0) ? null : new Media(cPtr, false);
  }

  /**
   * Get audio media for the specified media index. If the specified media<br>
   * index is not audio or invalid or inactive, exception will be thrown.<br>
   * <br>
   * @param med_idx       Media index, or -1 to specify any first audio<br>
   *                      media registered in the conference bridge.<br>
   * <br>
   * @return The audio media.
   */
  public AudioMedia getAudioMedia(int med_idx) throws java.lang.Exception {
    return new AudioMedia(pjsua2JNI.Call_getAudioMedia(swigCPtr, this, med_idx), true);
  }

  /**
   * Get video media in encoding direction for the specified media index.<br>
   * If the specified media index is not video or invalid or the direction<br>
   * is receive only, exception will be thrown.<br>
   * <br>
   * @param med_idx       Media index, or -1 to specify any first video<br>
   *                      media with encoding direction registered in the<br>
   *                      conference bridge.<br>
   * <br>
   * @return The video media.
   */
  public VideoMedia getEncodingVideoMedia(int med_idx) throws java.lang.Exception {
    return new VideoMedia(pjsua2JNI.Call_getEncodingVideoMedia(swigCPtr, this, med_idx), true);
  }

  /**
   * Get video media in decoding direction for the specified media index.<br>
   * If the specified media index is not video or invalid or the direction<br>
   * is send only, exception will be thrown.<br>
   * <br>
   * @param med_idx       Media index, or -1 to specify any first video<br>
   *                      media with decoding direction registered in the<br>
   *                      conference bridge.<br>
   * <br>
   * @return The video media.
   */
  public VideoMedia getDecodingVideoMedia(int med_idx) throws java.lang.Exception {
    return new VideoMedia(pjsua2JNI.Call_getDecodingVideoMedia(swigCPtr, this, med_idx), true);
  }

  /**
   * Check if remote peer support the specified capability.<br>
   * <br>
   * @param htype         The header type (pjsip_hdr_e) to be checked, which<br>
   *                      value may be:<br>
   *                      - PJSIP_H_ACCEPT<br>
   *                      - PJSIP_H_ALLOW<br>
   *                      - PJSIP_H_SUPPORTED<br>
   * @param hname         If htype specifies PJSIP_H_OTHER, then the header<br>
   *                      name must be supplied in this argument. Otherwise<br>
   *                      the value must be set to empty string ("").<br>
   * @param token         The capability token to check. For example, if <br>
   * <i>htype</i> is PJSIP_H_ALLOW, then <i>token</i> specifies the<br>
   *                      method names; if <i>htype</i> is PJSIP_H_SUPPORTED, then<br>
   *                      <i>token</i> specifies the extension names such as<br>
   *                      "100rel".<br>
   * <br>
   * @return PJSIP_DIALOG_CAP_SUPPORTED if the specified<br>
   *                      capability is explicitly supported, see<br>
   *                      pjsip_dialog_cap_status for more info.
   */
  public int remoteHasCap(int htype, String hname, String token) {
    return pjsua2JNI.Call_remoteHasCap(swigCPtr, this, htype, hname, token);
  }

  /**
   * Attach application specific data to the call. Application can then<br>
   * inspect this data by calling getUserData().<br>
   * <br>
   * @param user_data     Arbitrary data to be attached to the call.
   */
  public void setUserData(SWIGTYPE_p_void user_data) {
    pjsua2JNI.Call_setUserData(swigCPtr, this, SWIGTYPE_p_void.getCPtr(user_data));
  }

  /**
   * Get user data attached to the call, which has been previously set with<br>
   * setUserData().<br>
   * <br>
   * @return The user data.
   */
  public SWIGTYPE_p_void getUserData() {
    long cPtr = pjsua2JNI.Call_getUserData(swigCPtr, this);
    return (cPtr == 0) ? null : new SWIGTYPE_p_void(cPtr, false);
  }

  /**
   * Get the NAT type of remote's endpoint. This is a proprietary feature<br>
   * of PJSUA-LIB which sends its NAT type in the SDP when <i>natTypeInSdp</i><br>
   * is set in UaConfig.<br>
   * <br>
   * This function can only be called after SDP has been received from remote,<br>
   * which means for incoming call, this function can be called as soon as<br>
   * call is received as long as incoming call contains SDP, and for outgoing<br>
   * call, this function can be called only after SDP is received (normally in<br>
   * PJSIP_SC_OK (200) response to INVITE). As a general case, application<br>
   * should call this function after or in <i>onCallMediaState()</i> callback.<br>
   * <br>
   * @return The NAT type.<br>
   * <br>
   * @see Endpoint#natGetType(), natTypeInSdp
   */
  public int getRemNatType() throws java.lang.Exception {
    return pjsua2JNI.Call_getRemNatType(swigCPtr, this);
  }

  /**
   * Make outgoing call to the specified URI.<br>
   * <br>
   * @param dst_uri       URI to be put in the To header (normally is the same<br>
   *                      as the target URI).<br>
   * <br>
   * 
   */
  public void makeCall(String dst_uri, CallOpParam prm) throws java.lang.Exception {
    pjsua2JNI.Call_makeCall(swigCPtr, this, dst_uri, CallOpParam.getCPtr(prm), prm);
  }

  /**
   * Send response to incoming INVITE request with call setting param.<br>
   * Depending on the status code specified as parameter, this function may<br>
   * send provisional response, establish the call, or terminate the call.<br>
   * Notes about call setting:<br>
   *  - if call setting is changed in the subsequent call to this function,<br>
   *    only the first call setting supplied will applied. So normally<br>
   *    application will not supply call setting before getting confirmation<br>
   *    from the user.<br>
   *  - if no call setting is supplied when SDP has to be sent, i.e: answer<br>
   *    with status code 183 or 2xx, the default call setting will be used,<br>
   *    check CallSetting for its default values.<br>
   * <br>
   * <br>
   * <br>
   * <br>
   * 
   */
  public void answer(CallOpParam prm) throws java.lang.Exception {
    pjsua2JNI.Call_answer(swigCPtr, this, CallOpParam.getCPtr(prm), prm);
  }

  /**
   * Hangup call by using method that is appropriate according to the<br>
   * call state. This function is different than answering the call with<br>
   * 3xx-6xx response (with answer()), in that this function<br>
   * will hangup the call regardless of the state and role of the call,<br>
   * while answer() only works with incoming calls on EARLY<br>
   * state.<br>
   * <br>
   * <br>
   * <br>
   * 
   */
  public void hangup(CallOpParam prm) throws java.lang.Exception {
    pjsua2JNI.Call_hangup(swigCPtr, this, CallOpParam.getCPtr(prm), prm);
  }

  /**
   * Put the specified call on hold. This will send re-INVITE with the<br>
   * appropriate SDP to inform remote that the call is being put on hold.<br>
   * The final status of the request itself will be reported on the<br>
   * <i>onCallMediaState()</i> callback, which inform the application that<br>
   * the media state of the call has changed.<br>
   * <br>
   * <br>
   * 
   */
  public void setHold(CallOpParam prm) throws java.lang.Exception {
    pjsua2JNI.Call_setHold(swigCPtr, this, CallOpParam.getCPtr(prm), prm);
  }

  /**
   * Send re-INVITE.<br>
   * The final status of the request itself will be reported on the<br>
   * <i>onCallMediaState()</i> callback, which inform the application that<br>
   * the media state of the call has changed.<br>
   * <br>
   * <br>
   * <br>
   * 
   */
  public void reinvite(CallOpParam prm) throws java.lang.Exception {
    pjsua2JNI.Call_reinvite(swigCPtr, this, CallOpParam.getCPtr(prm), prm);
  }

  /**
   * Send UPDATE request.<br>
   * <br>
   * <br>
   * 
   */
  public void update(CallOpParam prm) throws java.lang.Exception {
    pjsua2JNI.Call_update(swigCPtr, this, CallOpParam.getCPtr(prm), prm);
  }

  /**
   * Initiate call transfer to the specified address. This function will send<br>
   * REFER request to instruct remote call party to initiate a new INVITE<br>
   * session to the specified destination/target.<br>
   * <br>
   * If application is interested to monitor the successfulness and<br>
   * the progress of the transfer request, it can implement<br>
   * <i>onCallTransferStatus()</i> callback which will report the progress<br>
   * of the call transfer request.<br>
   * <br>
   * @param dest          URI of new target to be contacted. The URI may be<br>
   *                      in name address or addr-spec format.<br>
   * 
   */
  public void xfer(String dest, CallOpParam prm) throws java.lang.Exception {
    pjsua2JNI.Call_xfer(swigCPtr, this, dest, CallOpParam.getCPtr(prm), prm);
  }

  /**
   * Initiate attended call transfer. This function will send REFER request<br>
   * to instruct remote call party to initiate new INVITE session to the URL<br>
   * of <i>destCall</i>. The party at <i>dest_call</i> then should "replace"<br>
   * the call with us with the new call from the REFER recipient.<br>
   * <br>
   * @param dest_call     The call to be replaced.<br>
   * <br>
   * 
   */
  public void xferReplaces(Call dest_call, CallOpParam prm) throws java.lang.Exception {
    pjsua2JNI.Call_xferReplaces(swigCPtr, this, Call.getCPtr(dest_call), dest_call, CallOpParam.getCPtr(prm), prm);
  }

  /**
   * Accept or reject redirection response. Application MUST call this<br>
   * function after it signaled PJSIP_REDIRECT_PENDING in the <br>
   * <i>onCallRedirected()</i> callback,<br>
   * to notify the call whether to accept or reject the redirection<br>
   * to the current target. Application can use the combination of<br>
   * PJSIP_REDIRECT_PENDING command in <i>onCallRedirected()</i> callback and<br>
   * this function to ask for user permission before redirecting the call.<br>
   * <br>
   * Note that if the application chooses to reject or stop redirection (by<br>
   * using PJSIP_REDIRECT_REJECT or PJSIP_REDIRECT_STOP respectively), the<br>
   * call disconnection callback will be called before this function returns.<br>
   * And if the application rejects the target, the <i>onCallRedirected()</i><br>
   * callback may also be called before this function returns if there is<br>
   * another target to try.<br>
   * <br>
   * @param cmd           Redirection operation to be applied to the current<br>
   *                      target. The semantic of this argument is similar<br>
   *                      to the description in the <i>onCallRedirected()</i><br>
   *                      callback, except that the PJSIP_REDIRECT_PENDING is<br>
   *                      not accepted here.
   */
  public void processRedirect(int cmd) throws java.lang.Exception {
    pjsua2JNI.Call_processRedirect(swigCPtr, this, cmd);
  }

  /**
   * Send DTMF digits to remote using RFC 2833 payload formats.<br>
   * <br>
   * @param digits        DTMF string digits to be sent.
   */
  public void dialDtmf(String digits) throws java.lang.Exception {
    pjsua2JNI.Call_dialDtmf(swigCPtr, this, digits);
  }

  /**
   * Send DTMF digits to remote.<br>
   * <br>
   * @param param     The send DTMF parameter.
   */
  public void sendDtmf(CallSendDtmfParam param) throws java.lang.Exception {
    pjsua2JNI.Call_sendDtmf(swigCPtr, this, CallSendDtmfParam.getCPtr(param), param);
  }

  /**
   * Send instant messaging inside INVITE session.<br>
   * <br>
   * <br>
   * <br>
   * <br>
   * 
   */
  public void sendInstantMessage(SendInstantMessageParam prm) throws java.lang.Exception {
    pjsua2JNI.Call_sendInstantMessage(swigCPtr, this, SendInstantMessageParam.getCPtr(prm), prm);
  }

  /**
   * Send IM typing indication inside INVITE session.<br>
   * <br>
   * <br>
   * 
   */
  public void sendTypingIndication(SendTypingIndicationParam prm) throws java.lang.Exception {
    pjsua2JNI.Call_sendTypingIndication(swigCPtr, this, SendTypingIndicationParam.getCPtr(prm), prm);
  }

  /**
   * Send arbitrary request with the call. This is useful for example to send<br>
   * INFO request. Note that application should not use this function to send<br>
   * requests which would change the invite session's state, such as<br>
   * re-INVITE, UPDATE, PRACK, and BYE.<br>
   * <br>
   * <br>
   * 
   */
  public void sendRequest(CallSendRequestParam prm) throws java.lang.Exception {
    pjsua2JNI.Call_sendRequest(swigCPtr, this, CallSendRequestParam.getCPtr(prm), prm);
  }

  /**
   * Dump call and media statistics to string.<br>
   * <br>
   * @param with_media    True to include media information too.<br>
   * @param indent        Spaces for left indentation.<br>
   * <br>
   * @return Call dump and media statistics string.
   */
  public String dump(boolean with_media, String indent) throws java.lang.Exception {
    return pjsua2JNI.Call_dump(swigCPtr, this, with_media, indent);
  }

  /**
   * Get the media stream index of the default video stream in the call.<br>
   * Typically this will just retrieve the stream index of the first<br>
   * activated video stream in the call. If none is active, it will return<br>
   * the first inactive video stream.<br>
   * <br>
   * @return The media stream index or -1 if no video stream<br>
   *                      is present in the call.
   */
  public int vidGetStreamIdx() {
    return pjsua2JNI.Call_vidGetStreamIdx(swigCPtr, this);
  }

  /**
   * Determine if video stream for the specified call is currently running<br>
   * (i.e. has been created, started, and not being paused) for the specified<br>
   * direction.<br>
   * <br>
   * @param med_idx       Media stream index, or -1 to specify default video<br>
   *                      media.<br>
   * @param dir           The direction to be checked.<br>
   * <br>
   * @return True if stream is currently running for the<br>
   *                      specified direction.
   */
  public boolean vidStreamIsRunning(int med_idx, int dir) {
    return pjsua2JNI.Call_vidStreamIsRunning(swigCPtr, this, med_idx, dir);
  }

  /**
   * Add, remove, modify, and/or manipulate video media stream for the<br>
   * specified call. This may trigger a re-INVITE or UPDATE to be sent<br>
   * for the call.<br>
   * <br>
   * @param op            The video stream operation to be performed,<br>
   *                      possible values are pjsua_call_vid_strm_op.<br>
   * @param param         The parameters for the video stream operation<br>
   *                      (see CallVidSetStreamParam).
   */
  public void vidSetStream(int op, CallVidSetStreamParam param) throws java.lang.Exception {
    pjsua2JNI.Call_vidSetStream(swigCPtr, this, op, CallVidSetStreamParam.getCPtr(param), param);
  }

  /**
   * Modify the video stream's codec parameter after the codec is opened.<br>
   * Note that not all codec backends support modifying parameters during<br>
   * runtime and only certain parameters can be changed.<br>
   * <br>
   * Currently, only Video Toolbox and OpenH264 backends support runtime<br>
   * adjustment of encoding bitrate (avg_bps and max_bps).<br>
   * <br>
   * @param med_idx       Video stream index.<br>
   * @param param         The new codec parameter.<br>
   * <br>
   * @return PJ_SUCCESS on success.
   */
  public void vidStreamModifyCodecParam(int med_idx, VidCodecParam param) throws java.lang.Exception {
    pjsua2JNI.Call_vidStreamModifyCodecParam(swigCPtr, this, med_idx, VidCodecParam.getCPtr(param), param);
  }

  /**
   * Modify the audio stream's codec parameter after the codec is opened.<br>
   * Note that not all codec parameters can be modified during run-time.<br>
   * Currently, only Opus codec supports changing key codec parameters<br>
   * such as bitrate and bandwidth, while other codecs may only be able to<br>
   * modify minor settings such as VAD or PLC.<br>
   * <br>
   * @param med_idx       Media stream index, or -1 to specify default audio<br>
   *                      media.<br>
   * @param param         The new codec parameter.<br>
   * <br>
   * @return PJ_SUCCESS on success.
   */
  public void audStreamModifyCodecParam(int med_idx, CodecParam param) throws java.lang.Exception {
    pjsua2JNI.Call_audStreamModifyCodecParam(swigCPtr, this, med_idx, CodecParam.getCPtr(param), param);
  }

  /**
   * Get media stream info for the specified media index.<br>
   * <br>
   * @param med_idx       Media stream index.<br>
   * <br>
   * @return The stream info.
   */
  public StreamInfo getStreamInfo(long med_idx) throws java.lang.Exception {
    return new StreamInfo(pjsua2JNI.Call_getStreamInfo(swigCPtr, this, med_idx), true);
  }

  /**
   * Get media stream statistic for the specified media index.<br>
   * <br>
   * @param med_idx       Media stream index.<br>
   * <br>
   * @return The stream statistic.
   */
  public StreamStat getStreamStat(long med_idx) throws java.lang.Exception {
    return new StreamStat(pjsua2JNI.Call_getStreamStat(swigCPtr, this, med_idx), true);
  }

  /**
   * Get media transport info for the specified media index.<br>
   * <br>
   * @param med_idx       Media stream index.<br>
   * <br>
   * @return The transport info.
   */
  public MediaTransportInfo getMedTransportInfo(long med_idx) throws java.lang.Exception {
    return new MediaTransportInfo(pjsua2JNI.Call_getMedTransportInfo(swigCPtr, this, med_idx), true);
  }

  /**
   * Internal function (callled by Endpoint( to process update to call<br>
   * medias when call media state changes.
   */
  public void processMediaUpdate(OnCallMediaStateParam prm) {
    pjsua2JNI.Call_processMediaUpdate(swigCPtr, this, OnCallMediaStateParam.getCPtr(prm), prm);
  }

  /**
   * Internal function (called by Endpoint) to process call state change.
   */
  public void processStateChange(OnCallStateParam prm) {
    pjsua2JNI.Call_processStateChange(swigCPtr, this, OnCallStateParam.getCPtr(prm), prm);
  }

  /**
   * Notify application when call state has changed.<br>
   * Application may then query the call info to get the<br>
   * detail call states by calling getInfo() function.<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onCallState(OnCallStateParam prm) {
    if (getClass() == Call.class) pjsua2JNI.Call_onCallState(swigCPtr, this, OnCallStateParam.getCPtr(prm), prm); else pjsua2JNI.Call_onCallStateSwigExplicitCall(swigCPtr, this, OnCallStateParam.getCPtr(prm), prm);
  }

  /**
   * This is a general notification callback which is called whenever<br>
   * a transaction within the call has changed state. Application can<br>
   * implement this callback for example to monitor the state of<br>
   * outgoing requests, or to answer unhandled incoming requests<br>
   * (such as INFO) with a final response.<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onCallTsxState(OnCallTsxStateParam prm) {
    if (getClass() == Call.class) pjsua2JNI.Call_onCallTsxState(swigCPtr, this, OnCallTsxStateParam.getCPtr(prm), prm); else pjsua2JNI.Call_onCallTsxStateSwigExplicitCall(swigCPtr, this, OnCallTsxStateParam.getCPtr(prm), prm);
  }

  /**
   * Notify application when media state in the call has changed.<br>
   * Normal application would need to implement this callback, e.g.<br>
   * to connect the call's media to sound device. When ICE is used,<br>
   * this callback will also be called to report ICE negotiation<br>
   * failure.<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onCallMediaState(OnCallMediaStateParam prm) {
    if (getClass() == Call.class) pjsua2JNI.Call_onCallMediaState(swigCPtr, this, OnCallMediaStateParam.getCPtr(prm), prm); else pjsua2JNI.Call_onCallMediaStateSwigExplicitCall(swigCPtr, this, OnCallMediaStateParam.getCPtr(prm), prm);
  }

  /**
   * Notify application when a call has just created a local SDP (for<br>
   * initial or subsequent SDP offer/answer). Application can implement<br>
   * this callback to modify the SDP, before it is being sent and/or<br>
   * negotiated with remote SDP, for example to apply per account/call<br>
   * basis codecs priority or to add custom/proprietary SDP attributes.<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onCallSdpCreated(OnCallSdpCreatedParam prm) {
    if (getClass() == Call.class) pjsua2JNI.Call_onCallSdpCreated(swigCPtr, this, OnCallSdpCreatedParam.getCPtr(prm), prm); else pjsua2JNI.Call_onCallSdpCreatedSwigExplicitCall(swigCPtr, this, OnCallSdpCreatedParam.getCPtr(prm), prm);
  }

  /**
   * Notify application when an audio media session is about to be created<br>
   * (as opposed to onStreamCreated(), which is called *after* the session<br>
   * has been created). The application may change<br>
   * some stream info parameter values, i.e: jbInit, jbMinPre, jbMaxPre,<br>
   * jbMax, useKa, rtcpSdesByeDisabled, jbDiscardAlgo (audio),<br>
   * vidCodecParam.encFmt (video).<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onStreamPreCreate(OnStreamPreCreateParam prm) {
    if (getClass() == Call.class) pjsua2JNI.Call_onStreamPreCreate(swigCPtr, this, OnStreamPreCreateParam.getCPtr(prm), prm); else pjsua2JNI.Call_onStreamPreCreateSwigExplicitCall(swigCPtr, this, OnStreamPreCreateParam.getCPtr(prm), prm);
  }

  /**
   * Notify application when audio media session is created and before it is<br>
   * registered to the conference bridge. Application may return different<br>
   * audio media port if it has added media processing port to the stream.<br>
   * This media port then will be added to the conference bridge instead.<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onStreamCreated(OnStreamCreatedParam prm) {
    if (getClass() == Call.class) pjsua2JNI.Call_onStreamCreated(swigCPtr, this, OnStreamCreatedParam.getCPtr(prm), prm); else pjsua2JNI.Call_onStreamCreatedSwigExplicitCall(swigCPtr, this, OnStreamCreatedParam.getCPtr(prm), prm);
  }

  /**
   * Notify application when audio media session has been unregistered from<br>
   * the conference bridge and about to be destroyed.<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onStreamDestroyed(OnStreamDestroyedParam prm) {
    if (getClass() == Call.class) pjsua2JNI.Call_onStreamDestroyed(swigCPtr, this, OnStreamDestroyedParam.getCPtr(prm), prm); else pjsua2JNI.Call_onStreamDestroyedSwigExplicitCall(swigCPtr, this, OnStreamDestroyedParam.getCPtr(prm), prm);
  }

  /**
   * Notify application upon incoming DTMF digits.<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onDtmfDigit(OnDtmfDigitParam prm) {
    if (getClass() == Call.class) pjsua2JNI.Call_onDtmfDigit(swigCPtr, this, OnDtmfDigitParam.getCPtr(prm), prm); else pjsua2JNI.Call_onDtmfDigitSwigExplicitCall(swigCPtr, this, OnDtmfDigitParam.getCPtr(prm), prm);
  }

  /**
   * Notify application upon incoming DTMF events.<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onDtmfEvent(OnDtmfEventParam prm) {
    if (getClass() == Call.class) pjsua2JNI.Call_onDtmfEvent(swigCPtr, this, OnDtmfEventParam.getCPtr(prm), prm); else pjsua2JNI.Call_onDtmfEventSwigExplicitCall(swigCPtr, this, OnDtmfEventParam.getCPtr(prm), prm);
  }

  /**
   * Notify application on call being transferred (i.e. REFER is received).<br>
   * Application can decide to accept/reject transfer request by setting<br>
   * the code (default is 202). When this callback is not implemented,<br>
   * the default behavior is to accept the transfer.<br>
   * <br>
   * If application decides to accept the transfer request, it must also<br>
   * instantiate the new Call object for the transfer operation and return<br>
   * this new Call object to prm.newCall. For the new Call instance,<br>
   * the account should use the same account as this call and the call ID<br>
   * must be set to PJSUA_INVALID_ID.<br>
   * <br>
   * If application does not specify new Call object, library will reuse the<br>
   * existing Call object for initiating the new call (to the transfer<br>
   * destination). In this case, any events from both calls (transferred and<br>
   * transferring) will be delivered to the same Call object, where the call<br>
   * ID will be switched back and forth between callbacks. Application must<br>
   * be careful to not destroy the Call object when receiving disconnection<br>
   * event of the transferred call after the transfer process is completed.<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onCallTransferRequest(OnCallTransferRequestParam prm) {
    if (getClass() == Call.class) pjsua2JNI.Call_onCallTransferRequest(swigCPtr, this, OnCallTransferRequestParam.getCPtr(prm), prm); else pjsua2JNI.Call_onCallTransferRequestSwigExplicitCall(swigCPtr, this, OnCallTransferRequestParam.getCPtr(prm), prm);
  }

  /**
   * Notify application of the status of previously sent call<br>
   * transfer request. Application can monitor the status of the<br>
   * call transfer request, for example to decide whether to<br>
   * terminate existing call.<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onCallTransferStatus(OnCallTransferStatusParam prm) {
    if (getClass() == Call.class) pjsua2JNI.Call_onCallTransferStatus(swigCPtr, this, OnCallTransferStatusParam.getCPtr(prm), prm); else pjsua2JNI.Call_onCallTransferStatusSwigExplicitCall(swigCPtr, this, OnCallTransferStatusParam.getCPtr(prm), prm);
  }

  /**
   * Notify application about incoming INVITE with Replaces header.<br>
   * Application may reject the request by setting non-2xx code.<br>
   * <br>
   * In this callback, application should create a new Call instance and<br>
   * return the Call object via prm.newCall. In creating the new Call<br>
   * instance, the account should use the same account as this call and<br>
   * the call ID must be set to PJSUA_INVALID_ID.<br>
   * <br>
   * If application does not specify new Call object, library will reuse the<br>
   * existing Call object for callbacks. In this case, any events from<br>
   * both calls (replaced and new) will be delivered to the same Call object,<br>
   * where the call ID will be switched back and forth between callbacks.<br>
   * Application must be careful to not destroy the Call object when<br>
   * receiving disconnection event of the replaced call after the transfer<br>
   * process is completed.<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onCallReplaceRequest(OnCallReplaceRequestParam prm) {
    if (getClass() == Call.class) pjsua2JNI.Call_onCallReplaceRequest(swigCPtr, this, OnCallReplaceRequestParam.getCPtr(prm), prm); else pjsua2JNI.Call_onCallReplaceRequestSwigExplicitCall(swigCPtr, this, OnCallReplaceRequestParam.getCPtr(prm), prm);
  }

  /**
   * Notify application that an existing call has been replaced with<br>
   * a new call. This happens when PJSUA-API receives incoming INVITE<br>
   * request with Replaces header.<br>
   * <br>
   * After this callback is called, normally PJSUA-API will disconnect<br>
   * this call and establish a new call.<br>
   * <br>
   * If not yet done in onCallReplaceRequest(), application can create<br>
   * the new Call instance and return the Call object via prm.newCall.<br>
   * In creating the new Call instance, the account should use the same<br>
   * account as this call and the call ID must be set to prm.newCallId.<br>
   * <br>
   * If the new Call instance has been setup in onCallReplaceRequest(),<br>
   * the prm.newCall should contain the new Call instance and application<br>
   * MUST not change it.<br>
   * <br>
   * If application does not specify new Call object, library will reuse the<br>
   * existing Call object for callbacks. In this case, any events from<br>
   * both calls (replaced and new) will be delivered to the same Call object,<br>
   * where the call ID will be switched back and forth between callbacks.<br>
   * Application must be careful to not destroy the Call object when<br>
   * receiving disconnection event of the replaced call after the transfer<br>
   * process is completed.<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onCallReplaced(OnCallReplacedParam prm) {
    if (getClass() == Call.class) pjsua2JNI.Call_onCallReplaced(swigCPtr, this, OnCallReplacedParam.getCPtr(prm), prm); else pjsua2JNI.Call_onCallReplacedSwigExplicitCall(swigCPtr, this, OnCallReplacedParam.getCPtr(prm), prm);
  }

  /**
   * Notify application when call has received new offer from remote<br>
   * (i.e. re-INVITE/UPDATE with SDP is received). Application can<br>
   * decide to accept/reject the offer by setting the code (default<br>
   * is PJSIP_SC_OK (200)). If the offer is accepted, application can update<br>
   * the call setting to be applied in the answer. When this callback is<br>
   * not implemented, the default behavior is to accept the offer using<br>
   * current call setting.<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onCallRxOffer(OnCallRxOfferParam prm) {
    if (getClass() == Call.class) pjsua2JNI.Call_onCallRxOffer(swigCPtr, this, OnCallRxOfferParam.getCPtr(prm), prm); else pjsua2JNI.Call_onCallRxOfferSwigExplicitCall(swigCPtr, this, OnCallRxOfferParam.getCPtr(prm), prm);
  }

  /**
   * Notify application when call has received a re-INVITE offer from<br>
   * the peer. It allows more fine-grained control over the response to<br>
   * a re-INVITE. If application sets prm.isAsync to true, it can send<br>
   * the reply manually using the function #pj::Call::answer() and setting<br>
   * the SDP answer. Otherwise, by default the re-INVITE will be<br>
   * answered automatically after the callback returns.<br>
   * <br>
   * Currently, this callback is only called for re-INVITE with<br>
   * SDP, but app should be prepared to handle the case of re-INVITE<br>
   * without SDP.<br>
   * <br>
   * Remarks: If manually answering at a later timing, application may<br>
   * need to monitor onCallTsxState() callback to check whether<br>
   * the re-INVITE is already answered automatically with<br>
   * PJSIP_SC_REQUEST_TERMINATED (487) due to being cancelled.<br>
   * <br>
   * Note: onCallRxOffer() will still be called after this callback,<br>
   * but only if prm.isAsync is false and prm.statusCode is PJSIP_SC_OK<br>
   * (200).<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onCallRxReinvite(OnCallRxReinviteParam prm) {
    if (getClass() == Call.class) pjsua2JNI.Call_onCallRxReinvite(swigCPtr, this, OnCallRxReinviteParam.getCPtr(prm), prm); else pjsua2JNI.Call_onCallRxReinviteSwigExplicitCall(swigCPtr, this, OnCallRxReinviteParam.getCPtr(prm), prm);
  }

  /**
   * Notify application when call has received INVITE with no SDP offer.<br>
   * Application can update the call setting (e.g: add audio/video), or<br>
   * enable/disable codecs, or update other media session settings from<br>
   * within the callback, however, as mandated by the standard (RFC3261<br>
   * section 14.2), it must ensure that the update overlaps with the<br>
   * existing media session (in codecs, transports, or other parameters)<br>
   * that require support from the peer, this is to avoid the need for<br>
   * the peer to reject the offer.<br>
   * <br>
   * When this callback is not implemented, the default behavior is to send<br>
   * SDP offer using current active media session (with all enabled codecs<br>
   * on each media type).<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onCallTxOffer(OnCallTxOfferParam prm) {
    if (getClass() == Call.class) pjsua2JNI.Call_onCallTxOffer(swigCPtr, this, OnCallTxOfferParam.getCPtr(prm), prm); else pjsua2JNI.Call_onCallTxOfferSwigExplicitCall(swigCPtr, this, OnCallTxOfferParam.getCPtr(prm), prm);
  }

  /**
   * Notify application on incoming MESSAGE request.<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onInstantMessage(OnInstantMessageParam prm) {
    if (getClass() == Call.class) pjsua2JNI.Call_onInstantMessage(swigCPtr, this, OnInstantMessageParam.getCPtr(prm), prm); else pjsua2JNI.Call_onInstantMessageSwigExplicitCall(swigCPtr, this, OnInstantMessageParam.getCPtr(prm), prm);
  }

  /**
   * Notify application about the delivery status of outgoing MESSAGE<br>
   * request.<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onInstantMessageStatus(OnInstantMessageStatusParam prm) {
    if (getClass() == Call.class) pjsua2JNI.Call_onInstantMessageStatus(swigCPtr, this, OnInstantMessageStatusParam.getCPtr(prm), prm); else pjsua2JNI.Call_onInstantMessageStatusSwigExplicitCall(swigCPtr, this, OnInstantMessageStatusParam.getCPtr(prm), prm);
  }

  /**
   * Notify application about typing indication.<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onTypingIndication(OnTypingIndicationParam prm) {
    if (getClass() == Call.class) pjsua2JNI.Call_onTypingIndication(swigCPtr, this, OnTypingIndicationParam.getCPtr(prm), prm); else pjsua2JNI.Call_onTypingIndicationSwigExplicitCall(swigCPtr, this, OnTypingIndicationParam.getCPtr(prm), prm);
  }

  /**
   * This callback is called when the call is about to resend the<br>
   * INVITE request to the specified target, following the previously<br>
   * received redirection response.<br>
   * <br>
   * Application may accept the redirection to the specified target,<br>
   * reject this target only and make the session continue to try the next<br>
   * target in the list if such target exists, stop the whole<br>
   * redirection process altogether and cause the session to be<br>
   * disconnected, or defer the decision to ask for user confirmation.<br>
   * <br>
   * This callback is optional,<br>
   * the default behavior is to NOT follow the redirection response.<br>
   * <br>
   * @param prm       Callback parameter.<br>
   * <br>
   * @return Action to be performed for the target. Set this<br>
   *                  parameter to one of the value below:<br>
   *                  - PJSIP_REDIRECT_ACCEPT: immediately accept the<br>
   *                    redirection. When set, the call will immediately<br>
   *                    resend INVITE request to the target.<br>
   *                  - PJSIP_REDIRECT_ACCEPT_REPLACE: immediately accept<br>
   *                    the redirection and replace the To header with the<br>
   *                    current target. When set, the call will immediately<br>
   *                    resend INVITE request to the target.<br>
   *                  - PJSIP_REDIRECT_REJECT: immediately reject this<br>
   *                    target. The call will continue retrying with<br>
   *                    next target if present, or disconnect the call<br>
   *                    if there is no more target to try.<br>
   *                  - PJSIP_REDIRECT_STOP: stop the whole redirection<br>
   *                    process and immediately disconnect the call. The<br>
   *                    onCallState() callback will be called with<br>
   *                    PJSIP_INV_STATE_DISCONNECTED state immediately<br>
   *                    after this callback returns.<br>
   *                  - PJSIP_REDIRECT_PENDING: set to this value if<br>
   *                    no decision can be made immediately (for example<br>
   *                    to request confirmation from user). Application<br>
   *                    then MUST call processRedirect()<br>
   *                    to either accept or reject the redirection upon<br>
   *                    getting user decision.
   */
  public int onCallRedirected(OnCallRedirectedParam prm) {
    return (getClass() == Call.class) ? pjsua2JNI.Call_onCallRedirected(swigCPtr, this, OnCallRedirectedParam.getCPtr(prm), prm) : pjsua2JNI.Call_onCallRedirectedSwigExplicitCall(swigCPtr, this, OnCallRedirectedParam.getCPtr(prm), prm);
  }

  /**
   * This callback is called when media transport state is changed.<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onCallMediaTransportState(OnCallMediaTransportStateParam prm) {
    if (getClass() == Call.class) pjsua2JNI.Call_onCallMediaTransportState(swigCPtr, this, OnCallMediaTransportStateParam.getCPtr(prm), prm); else pjsua2JNI.Call_onCallMediaTransportStateSwigExplicitCall(swigCPtr, this, OnCallMediaTransportStateParam.getCPtr(prm), prm);
  }

  /**
   * Notification about media events such as video notifications. This<br>
   * callback will most likely be called from media threads, thus<br>
   * application must not perform heavy processing in this callback.<br>
   * Especially, application must not destroy the call or media in this<br>
   * callback. If application needs to perform more complex tasks to<br>
   * handle the event, it should post the task to another thread.<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onCallMediaEvent(OnCallMediaEventParam prm) {
    if (getClass() == Call.class) pjsua2JNI.Call_onCallMediaEvent(swigCPtr, this, OnCallMediaEventParam.getCPtr(prm), prm); else pjsua2JNI.Call_onCallMediaEventSwigExplicitCall(swigCPtr, this, OnCallMediaEventParam.getCPtr(prm), prm);
  }

  /**
   * This callback can be used by application to implement custom media<br>
   * transport adapter for the call, or to replace the media transport<br>
   * with something completely new altogether.<br>
   * <br>
   * This callback is called when a new call is created. The library has<br>
   * created a media transport for the call, and it is provided as the<br>
   * <i>mediaTp</i> argument of this callback. The callback may change it<br>
   * with the instance of media transport to be used by the call.<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onCreateMediaTransport(OnCreateMediaTransportParam prm) {
    if (getClass() == Call.class) pjsua2JNI.Call_onCreateMediaTransport(swigCPtr, this, OnCreateMediaTransportParam.getCPtr(prm), prm); else pjsua2JNI.Call_onCreateMediaTransportSwigExplicitCall(swigCPtr, this, OnCreateMediaTransportParam.getCPtr(prm), prm);
  }

  /**
   * Warning: deprecated and may be removed in future release.<br>
   * Application can set SRTP crypto settings (including keys) and<br>
   * keying methods via AccountConfig.mediaConfig.srtpOpt.<br>
   * See also ticket #2100.<br>
   * <br>
   * This callback is called when SRTP media transport is created.<br>
   * Application can modify the SRTP setting <i>srtpOpt</i> to specify<br>
   * the cryptos and keys which are going to be used. Note that<br>
   * application should not modify the field<br>
   * <i>pjmedia_srtp_setting.close_member_tp</i> and can only modify<br>
   * the field <i>pjmedia_srtp_setting.use</i> for initial INVITE.<br>
   * <br>
   * @param prm       Callback parameter.
   */
  public void onCreateMediaTransportSrtp(OnCreateMediaTransportSrtpParam prm) {
    if (getClass() == Call.class) pjsua2JNI.Call_onCreateMediaTransportSrtp(swigCPtr, this, OnCreateMediaTransportSrtpParam.getCPtr(prm), prm); else pjsua2JNI.Call_onCreateMediaTransportSrtpSwigExplicitCall(swigCPtr, this, OnCreateMediaTransportSrtpParam.getCPtr(prm), prm);
  }

}
